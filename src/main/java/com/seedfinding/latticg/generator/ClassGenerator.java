package com.seedfinding.latticg.generator;

import com.seedfinding.latticg.JavaRandomReverser;
import com.seedfinding.latticg.math.component.BigMatrix;
import com.seedfinding.latticg.math.component.BigMatrixUtil;
import com.seedfinding.latticg.math.component.BigVector;
import com.seedfinding.latticg.math.lattice.enumerate.EnumerateRt;
import com.seedfinding.latticg.math.optimize.Optimize;
import com.seedfinding.latticg.reversal.Program;
import com.seedfinding.latticg.reversal.calltype.CallType;
import com.seedfinding.latticg.reversal.calltype.java.NextBooleanCall;
import com.seedfinding.latticg.reversal.calltype.java.NextDoubleCall;
import com.seedfinding.latticg.reversal.calltype.java.NextFloatCall;
import com.seedfinding.latticg.reversal.calltype.java.NextIntCall;
import com.seedfinding.latticg.reversal.calltype.java.NextLongCall;
import com.seedfinding.latticg.reversal.calltype.java.UnboundedNextIntCall;
import com.seedfinding.latticg.util.DeserializeRt;
import com.seedfinding.latticg.util.Mth;

import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.stream.Collectors;
import java.util.stream.LongStream;

public final class ClassGenerator {
    private static final String TAB = "    ";
    private static final String TAB2 = TAB + TAB;
    private static final String TAB3 = TAB2 + TAB;

    private String fileHeader = "";
    private final String packageName;
    private final String className;
    private final Program program;

    private final StringBuilder classBody = new StringBuilder();
    private final StringBuilder parameters = new StringBuilder();
    private final StringBuilder boundsConfig = new StringBuilder();
    private final Set<String> imports = new TreeSet<>();
    private int latticeIndex = 0;

    public ClassGenerator(String packageName, String className, Program program) {
        this.packageName = packageName;
        this.className = className;
        this.program = program;
    }

    public ClassGenerator withFileHeader(String fileHeader) {
        this.fileHeader = fileHeader;
        return this;
    }

    public String generate() {
        classBody.setLength(0);
        parameters.setLength(0);
        boundsConfig.setLength(0);
        imports.clear();
        latticeIndex = 0;

        classBody.append("public final class ").append(this.className).append(" {\n");
        classBody.append(TAB + "private ").append(this.className).append("() {}\n");
        generateBody();
        classBody.append("}\n");

        StringBuilder result = new StringBuilder();
        if (!this.fileHeader.isEmpty()) {
            result.append(this.fileHeader).append("\n\n");
        }
        result.append("package ").append(packageName).append(";\n\n");
        if (!imports.isEmpty()) {
            result.append(imports.stream().map(i -> "import " + i + ";").collect(Collectors.joining("\n"))).append("\n\n");
        }
        result.append("// CLASS GENERATED BY LATTICG, DO NOT EDIT MANUALLY\n");
        result.append(classBody);

        return result.toString();
    }

    private void generateBody() {
        if (!program.getFilteredSkips().isEmpty()) {
            throw new IllegalStateException("ClassGenerator does not support filtered skips");
        }

        JavaRandomReverser reverser = new JavaRandomReverser(Collections.emptyList());

        List<CallType<?>> calls = program.getCalls();
        List<Long> skips = program.getSkips();
        for (int i = 0; i < calls.size(); i++) {
            CallType<?> call = calls.get(i);
            reverser.addUnmeasuredSeeds(skips.get(i));

            if (call instanceof NextBooleanCall) {
                reverser.addNextBooleanCall(false);
            } else if (call instanceof NextDoubleCall) {
                reverser.addNextDoubleCall(0, 0, true, true);
            } else if (call instanceof NextFloatCall) {
                reverser.addNextFloatCall(0, 0, true, true);
            } else if (call instanceof NextIntCall) {
                reverser.addNextIntCall(((NextIntCall) call).getBound(), 0, 0);
            } else if (call instanceof UnboundedNextIntCall) {
                reverser.addNextIntCall(0, 0);
            } else if (call instanceof NextLongCall) {
                reverser.addNextLongCall(0, 0);
            } else if (call instanceof NextFloatCall.FloatRange) {
                reverser.addNextFloatCall(0.0F, 0.5F);
            } else if (call instanceof NextIntCall.IntRange) {
                int bound = ((NextIntCall.IntRange) call).getBound();
                reverser.addNextIntCall(bound, 0, bound / 2);
            } else if (call instanceof UnboundedNextIntCall.IntRange) {
                reverser.addNextIntCall(0, Integer.MAX_VALUE - 1);
            } else if (call instanceof NextDoubleCall.DoubleRange) {
                reverser.addNextDoubleCall(0.0D, 0.5D);
            } else if (call instanceof NextLongCall.LongRange) {
                reverser.addNextLongCall(0, Long.MAX_VALUE);
            } else if (call instanceof NextFloatCall.Ranged) {
                reverser.addNextFloatCall(0, Mth.clamp(((NextFloatCall.Ranged) call).getExpectedSize(), 0, 1));
            } else if (call instanceof NextIntCall.Ranged) {
                NextIntCall.Ranged rangedCall = (NextIntCall.Ranged) call;
                reverser.addNextIntCall(rangedCall.getBound(), 0, Mth.clamp(rangedCall.getExpectedSize(), 0, rangedCall.getBound() - 1));
            } else if (call instanceof UnboundedNextIntCall.Ranged) {
                reverser.addNextIntCall(0, ((UnboundedNextIntCall.Ranged) call).getExpectedSize());
            } else if (call instanceof NextDoubleCall.Ranged) {
                reverser.addNextDoubleCall(0, Mth.clamp(((NextDoubleCall.Ranged) call).getExpectedSize(), 0x1.0p-26, 1));
            } else if (call instanceof NextLongCall.Ranged) {
                reverser.addNextLongCall(0, Math.max(((NextLongCall.Ranged) call).getExpectedSize(), 1L << 32));
            } else {
                throw new IllegalStateException("ClassGenerator does not support " + call.getClass().getSimpleName() + " call type");
            }
        }

        JavaRandomReverser.GenerationInfo generationInfo = reverser.createGenerationInfo();

        classBody.append(TAB + "private static final ");
        appendClassName(classBody, BigMatrix.class);
        classBody.append(" BASIS = ");
        appendClassName(classBody, DeserializeRt.class);
        classBody.append(".mat(\n");
        classBody.append(SerializeUtil.matrixToStringLiteral(TAB2, generationInfo.basis)).append(");\n");

        BigMatrix rootInverse = BigMatrixUtil.inverse(generationInfo.basis);
        classBody.append(TAB + "private static final ");
        appendClassName(classBody, BigMatrix.class);
        classBody.append(" ROOT_INV = ");
        appendClassName(classBody, DeserializeRt.class);
        classBody.append(".mat(\n");
        classBody.append(SerializeUtil.matrixToStringLiteral(TAB2, rootInverse)).append(");\n");

        classBody.append(TAB + "private static final ");
        appendClassName(classBody, BigVector.class);
        classBody.append(" ORIGIN = ");
        appendClassName(classBody, DeserializeRt.class);
        classBody.append(".vec(\n");
        classBody.append(SerializeUtil.vectorToStringLiteral(TAB2, generationInfo.offset)).append(");\n");

        classBody.append(TAB + "private static final ");
        appendClassName(classBody, BigVector.class);
        classBody.append(" ROOT_ORIGIN = ");
        appendClassName(classBody, DeserializeRt.class);
        classBody.append(".vec(\n");
        classBody.append(SerializeUtil.vectorToStringLiteral(TAB2, rootInverse.multiply(generationInfo.offset))).append(");\n\n");

        classBody.append(TAB + "/**\n");
        classBody.append(TAB + " * Finds all values of {@code seed} that could produce the given results in the following code:\n");
        classBody.append(TAB + " * <pre>{@code\n");
        classBody.append(TAB + " *    Random rand = new Random(seed ^ 0x5DEECE66DL);\n");

        int nextBooleans = 0;
        int nextDoubles = 0;
        int nextFloats = 0;
        int nextInts = 0;
        int nextLongs = 0;

        for (int i = 0; i < calls.size(); i++) {
            long skipsHere = skips.get(i);
            if (skipsHere != 0) {
                if (skipsHere > 0) {
                    classBody.append(TAB + " *    // Skip ").append(skipsHere).append(" random call");
                } else {
                    classBody.append(TAB + " *    // Go backwards by ").append(-skipsHere).append(" random call");
                }
                if (Math.abs(skipsHere) != 1) {
                    classBody.append('s');
                }
                classBody.append('\n');
            }

            CallType<?> call = calls.get(i);

            if (parameters.length() != 0) {
                parameters.append(", ");
            }

            if (call instanceof NextBooleanCall) {
                String varName = "nextBoolean" + (++nextBooleans);
                nextBooleanCall((NextBooleanCall) call, varName);
            } else if (call instanceof NextDoubleCall) {
                String varName = "nextDouble" + (++nextDoubles);
                nextDoubleCall(varName, nextDoubles);
            } else if (call instanceof NextFloatCall) {
                String varName = "nextFloat" + (++nextFloats);
                nextFloatCall(varName, nextFloats);
            } else if (call instanceof NextIntCall) {
                String varName = "nextInt" + (++nextInts);
                nextIntCall((NextIntCall) call, varName);
            } else if (call instanceof UnboundedNextIntCall) {
                String varName = "nextInt" + (++nextInts);
                unboundedNextIntCall(varName);
            } else if (call instanceof NextLongCall) {
                String varName = "nextLong" + (++nextLongs);
                nextLongCall(varName, nextLongs);
            } else if (call instanceof NextFloatCall.FloatRange) {
                String varName = "nextFloat" + (++nextFloats);
                floatRangeCall((NextFloatCall.FloatRange) call, varName);
            } else if (call instanceof NextIntCall.IntRange) {
                String varName = "nextInt" + (++nextInts);
                intRangeCall((NextIntCall.IntRange) call, varName);
            } else if (call instanceof UnboundedNextIntCall.IntRange) {
                String varName = "nextInt" + (++nextInts);
                unboundedIntRangeCall((UnboundedNextIntCall.IntRange) call, varName);
            } else if (call instanceof NextDoubleCall.DoubleRange) {
                String varName = "nextDouble" + (++nextDoubles);
                doubleRangeCall((NextDoubleCall.DoubleRange) call, varName);
            } else if (call instanceof NextLongCall.LongRange) {
                String varName = "nextLong" + (++nextLongs);
                longRangeCall((NextLongCall.LongRange) call, varName);
            } else if (call instanceof NextFloatCall.Ranged) {
                nextFloats++;
                floatRangedCall("minNextFloat" + nextFloats, "maxNextFloat" + nextFloats, nextFloats);
            } else if (call instanceof NextIntCall.Ranged) {
                nextInts++;
                intRangedCall((NextIntCall.Ranged) call, "minNextInt" + nextInts, "maxNextInt" + nextInts, nextInts);
            } else if (call instanceof UnboundedNextIntCall.Ranged) {
                nextInts++;
                unboundedIntRangedCall("minNextInt" + nextInts, "maxNextInt" + nextInts, nextInts);
            } else if (call instanceof NextDoubleCall.Ranged) {
                nextDoubles++;
                doubleRangedCall("minNextDouble" + nextDoubles, "maxNextDoubles" + nextDoubles, nextDoubles);
            } else if (call instanceof NextLongCall.Ranged) {
                nextLongs++;
                longRangedCall("minNextLong" + nextLongs, "maxNextLongs" + nextLongs, nextLongs);
            } else {
                throw new AssertionError("Unknown call type should have been caught in previous loop");
            }
        }

        if (latticeIndex != generationInfo.dimensions) {
            throw new AssertionError("Not all dimensions in the lattice have been accounted for");
        }

        classBody.append(TAB + " * }</pre>\n");
        classBody.append(TAB + " *\n");
        classBody.append(String.format(TAB + " * <p>This code skips %f%% of seeds in its search.\n", (1 - generationInfo.successChance) * 100));
        classBody.append(TAB + " */\n");
        classBody.append(TAB + "public static ");
        appendClassName(classBody, LongStream.class);
        classBody.append(" getSeeds(").append(parameters).append(") {\n");
        classBody.append(TAB2);
        appendClassName(classBody, Optimize.Builder.class);
        classBody.append(" builder = ");
        appendClassName(classBody, Optimize.Builder.class);
        classBody.append(".ofSize(").append(generationInfo.dimensions).append(");\n");
        classBody.append(boundsConfig);
        classBody.append(TAB2 + "return ");
        appendClassName(classBody, EnumerateRt.class);
        classBody.append(".enumerate(BASIS, ORIGIN, builder.build(), ROOT_INV, ROOT_ORIGIN)\n");
        classBody.append(String.format(TAB3 + ".mapToLong(vec -> (vec.get(0).getNumerator().longValue() * 0x%xL + 0x%xL) & ((1L << 48) - 1));\n", generationInfo.r.multiplier, generationInfo.r.addend));
        classBody.append(TAB + "}\n");
    }

    private void nextBooleanCall(NextBooleanCall call, String varName) {
        classBody.append(TAB + " *    boolean ").append(varName).append(" = ");
        if (call.isInverted()) {
            classBody.append('!');
        }
        classBody.append("rand.nextBoolean();\n");
        parameters.append("boolean ").append(varName);

        boundsConfig.append(String.format(TAB2 + "if (%s) {\n", varName));
        boundsConfig.append(String.format(TAB3 + "builder.withLowerBound(%d, %s).withUpperBound(%d, %s);\n",
            latticeIndex, call.isInverted() ? "0" : "1L << 47",
            latticeIndex, call.isInverted() ? "(1L << 47) - 1" : "(1L << 48) - 1"));
        boundsConfig.append(TAB2 + "} else {\n");
        boundsConfig.append(String.format(TAB3 + "builder.withLowerBound(%d, %s).withUpperBound(%d, %s);\n",
            latticeIndex, call.isInverted() ? "1L << 47" : "0",
            latticeIndex, call.isInverted() ? "(1L << 48) - 1" : "(1L << 47) - 1"));
        boundsConfig.append(TAB2 + "}\n");
        latticeIndex++;
    }

    private void nextDoubleCall(String varName, int nextDoubles) {
        classBody.append(TAB + " *    double ").append(varName).append(" = rand.nextDouble();\n");
        parameters.append("double ").append(varName);

        String longVar = "longDouble" + nextDoubles;
        boundsConfig.append(String.format(TAB2 + "long %s = (long) (%s * 0x1.0p53);\n", longVar, varName));

        boundsConfig.append(String.format(TAB2 + "builder.withLowerBound(%d, %s >> 27 << 22).withUpperBound(%d, (%s >> 27 << 22) | 0x3fffff);\n",
            latticeIndex, longVar, latticeIndex, longVar));
        latticeIndex++;

        boundsConfig.append(String.format(TAB2 + "builder.withLowerBound(%d, (%s & 0x7ffffff) << 21).withUpperBound(%d, ((%s & 0x7ffffff) << 21) | 0x1fffff);\n",
            latticeIndex, longVar, latticeIndex, longVar));
        latticeIndex++;
    }

    private void nextFloatCall(String varName, int nextFloats) {
        classBody.append(TAB + " *    float ").append(varName).append(" = rand.nextFloat();\n");
        parameters.append("float ").append(varName);

        String longVar = "longFloat" + nextFloats;
        boundsConfig.append(String.format(TAB2 + "long %s = (long) (%s * 0x1.0p24F);\n", longVar, varName));
        boundsConfig.append(String.format(TAB2 + "builder.withLowerBound(%d, %s << 24).withUpperBound(%d, (%s << 24) | 0xffffff);\n",
            latticeIndex, longVar, latticeIndex, longVar));
        latticeIndex++;
    }

    private void nextIntCall(NextIntCall call, String varName) {
        classBody.append(TAB + " *    int ").append(varName).append(" = rand.nextInt(").append(call.getBound()).append(");\n");
        parameters.append("int ").append(varName);

        if ((call.getBound() & -call.getBound()) == call.getBound()) {
            int log = Integer.numberOfTrailingZeros(call.getBound());
            boundsConfig.append(String.format(TAB2 + "builder.withLowerBound(%d, (long) %s << %d).withUpperBound(%d, ((long) (%s + 1) << %d) - 1);\n",
                latticeIndex, varName, 48 - log, latticeIndex, varName, 48 - log));
            latticeIndex++;
        } else {
            long residue = (1L << 48) % ((long) call.getBound() << 17);
            boundsConfig.append(String.format(TAB2 + "builder.withLowerBound(%d, 0).withUpperBound(%d, (1L << 48) - %dL);\n",
                latticeIndex, latticeIndex, residue));
            latticeIndex++;
            boundsConfig.append(String.format(TAB2 + "builder.withLowerBound(%d, (long) %s << 17).withUpperBound(%d, ((long) %s << 17) | 0x1ffff);\n",
                latticeIndex, varName, latticeIndex, varName));
            latticeIndex++;
        }
    }

    private void unboundedNextIntCall(String varName) {
        classBody.append(TAB + " *    int ").append(varName).append(" = rand.nextInt();\n");
        parameters.append("int ").append(varName);

        boundsConfig.append(String.format(TAB2 + "builder.withLowerBound(%d, (long) %s << 16).withUpperBound(%d, ((long) (%s + 1) << 16) - 1);\n",
            latticeIndex, varName, latticeIndex, varName));
        latticeIndex++;
    }

    private void nextLongCall(String varName, int nextLongs) {
        classBody.append(TAB + " *    long ").append(varName).append(" = rand.nextLong();\n");
        parameters.append("long ").append(varName);

        String firstSeedName = "longFirstSeed" + nextLongs;
        boundsConfig.append(String.format(TAB2 + "long %s = %s >>> 32 << 16;\n", firstSeedName, varName));
        boundsConfig.append(String.format(TAB2 + "if (%s < 0) {\n", varName));
        boundsConfig.append(String.format(TAB3 + "%s += (1L << 16);\n", firstSeedName));
        boundsConfig.append(TAB2 + "}\n");

        boundsConfig.append(String.format(TAB2 + "builder.withLowerBound(%d, %s).withUpperBound(%d, %s + (1L << 16) - 1);\n",
            latticeIndex, firstSeedName, latticeIndex, firstSeedName));
        latticeIndex++;
        boundsConfig.append(String.format(TAB2 + "builder.withLowerBound(%d, (%s & 0xffffffffL) << 16).withUpperBound(%d, (((%s & 0xffffffffL) + 1) << 16) - 1);\n",
            latticeIndex, varName, latticeIndex, varName));
        latticeIndex++;
    }

    private void floatRangeCall(NextFloatCall.FloatRange call, String varName) {
        boolean hasLowerBound = call.getMin() != 0.0F || call.isMinStrict();
        boolean hasUpperBound = call.getMax() != 1.0F || !call.isMaxStrict();

        if (hasLowerBound && hasUpperBound) {
            throw new IllegalStateException("ClassGenerator does not support nextFloat with two bounds");
        } else if (hasLowerBound) {
            classBody.append(String.format(TAB + " *    boolean %s = rand.nextFloat() %s %fF;\n",
                varName,
                call.isMinStrict() ? (call.isInverted() ? "<=" : ">") : (call.isInverted() ? "<" : ">="),
                call.getMin()));
        } else if (hasUpperBound) {
            classBody.append(String.format(TAB + " *    boolean %s = rand.nextFloat() %s %fF;\n",
                varName,
                call.isMaxStrict() ? (call.isInverted() ? ">=" : "<") : (call.isInverted() ? ">" : "<="),
                call.getMax()));
        } else {
            classBody.append(TAB + " *    rand.nextFloat();\n");
            classBody.append(String.format(TAB + " *    boolean %s = %s;\n", varName, !call.isInverted()));
        }
        parameters.append("boolean ").append(varName);

        if (hasLowerBound || hasUpperBound) {
            boundsConfig.append(String.format(TAB2 + "if (%s) {\n", varName));
            String ifTrue = String.format(TAB3 + "builder.withLowerBound(%d, %s(long) (%fF * 0x1.0p24F)%s << 24).withUpperBound(%d, (%s(long) (%fF * 0x1.0p24F)%s << 24) - 1);\n",
                latticeIndex, call.isMinStrict() ? "(" : "", call.getMin(), call.isMinStrict() ? " + 1)" : "",
                latticeIndex, !call.isMaxStrict() ? "(" : "", call.getMax(), !call.isMaxStrict() ? " + 1)" : "");
            String ifFalse;
            if (hasLowerBound) {
                ifFalse = String.format(TAB3 + "builder.withLowerBound(%d, 0).withUpperBound(%d, (%s(long) (%fF * 0x1.0p24F)%s << 24) - 1);\n",
                    latticeIndex, latticeIndex, call.isMinStrict() ? "(" : "", call.getMin(), call.isMinStrict() ? " + 1)" : "");
            } else {
                ifFalse = String.format(TAB3 + "builder.withLowerBound(%d, %s(long) (%fF * 0x1.0p24F)%s << 24).withUpperBound(%d, (1L << 48) - 1);\n",
                    latticeIndex, !call.isMaxStrict() ? "(" : "", call.getMax(), !call.isMaxStrict() ? " + 1)" : "", latticeIndex);
            }
            boundsConfig.append(call.isInverted() ? ifFalse : ifTrue);
            boundsConfig.append(TAB2 + "} else {\n");
            boundsConfig.append(call.isInverted() ? ifTrue : ifFalse);
            boundsConfig.append(TAB2 + "}\n");
        } else {
            boundsConfig.append(TAB2 + "if (");
            if (!call.isInverted()) {
                boundsConfig.append('!');
            }
            boundsConfig.append(varName).append(") {\n");
            boundsConfig.append(TAB3 + "return ");
            appendClassName(boundsConfig, LongStream.class);
            boundsConfig.append(".empty();\n");
            boundsConfig.append(TAB2 + "}\n");
        }
        latticeIndex++;
    }

    private void intRangeCall(NextIntCall.IntRange call, String varName) {
        int min = call.getMin();
        int max = call.getMax();
        if (call.isMinStrict()) {
            min++;
        }
        if (call.isMaxStrict()) {
            max--;
        }

        if (min > 0 && max < call.getBound() - 1) {
            throw new IllegalStateException("ClassGenerator does not support nextInt with two bounds");
        }

        if (min <= 0 && max >= call.getBound() - 1) {
            classBody.append(TAB + " *    rand.nextInt(").append(call.getBound()).append(");\n");
            classBody.append(TAB + " *    boolean ").append(varName).append(" = true;\n");
            parameters.append("boolean ").append(varName);
            boundsConfig.append(TAB2 + "if (");
            if (!call.isInverted()) {
                boundsConfig.append('!');
            }
            boundsConfig.append(varName).append(") {\n");
            boundsConfig.append(TAB3 + "return ");
            appendClassName(boundsConfig, LongStream.class);
            boundsConfig.append(".empty();\n");
            boundsConfig.append(TAB2 + "}\n");
            latticeIndex++;
            return;
        }

        classBody.append(String.format(TAB + " *    boolean %s = rand.nextInt(%d) %s %d;\n",
            varName,
            call.getBound(),
            min > 0 ? (call.isMinStrict() ? (call.isInverted() ? "<=" : ">") : (call.isInverted() ? "<": ">="))
                : (call.isMaxStrict() ? (call.isInverted() ? ">=" : "<") : (call.isInverted() ? ">" : "<=")),
            min > 0 ? call.getMin() : call.getMax()
        ));
        parameters.append("boolean ").append(varName);

        if ((call.getBound() & -call.getBound()) == call.getBound()) {
            int log = Integer.numberOfTrailingZeros(call.getBound());

            String ifTrue, ifFalse;
            if (min > 0) {
                ifTrue = String.format(TAB3 + "builder.withLowerBound(%d, %dL << %d).withUpperBound(%d, (1L << 48) - 1);\n",
                    latticeIndex, min, 48 - log, latticeIndex);
                ifFalse = String.format(TAB3 + "builder.withLowerBound(%d, 0).withUpperBound(%d, (%dL << %d) - 1);\n",
                    latticeIndex, latticeIndex, min, 48 - log);
            } else {
                ifTrue = String.format(TAB3 + "builder.withLowerBound(%d, 0).withUpperBound(%d, (%dL << %d) - 1);\n",
                    latticeIndex, latticeIndex, max + 1, 48 - log);
                ifFalse = String.format(TAB3 + "builder.withLowerBound(%d, %dL << %d).withUpperBound(%d, (1L << 48) - 1);\n",
                    latticeIndex, max + 1, 48 - log, latticeIndex);
            }

            boundsConfig.append(String.format(TAB2 + "if(%s) {\n", varName));
            boundsConfig.append(call.isInverted() ? ifFalse : ifTrue);
            boundsConfig.append(TAB2 + "} else {\n");
            boundsConfig.append(call.isInverted() ? ifTrue : ifFalse);
            boundsConfig.append(TAB2 + "}\n");
            latticeIndex++;
        } else {
            long residue = (1L << 48) % ((long) call.getBound() << 17);
            boundsConfig.append(String.format(TAB2 + "builder.withLowerBound(%d, 0).withUpperBound(%d, (1L << 48) - %d);\n",
                latticeIndex, latticeIndex, residue));
            latticeIndex++;

            String ifTrue, ifFalse;
            if (min > 0) {
                ifTrue = String.format(TAB3 + "builder.withLowerBound(%d, %dL << 17).withUpperBound(%d, (1L << 48) - 1);\n",
                    latticeIndex, min, latticeIndex);
                ifFalse = String.format(TAB3 + "builder.withLowerBound(%d, 0).withUpperBound(%d, (%dL << 17) - 1);\n",
                    latticeIndex, latticeIndex, min);
            } else {
                ifTrue = String.format(TAB3 + "builder.withLowerBound(%d, 0).withUpperBound(%d, (%dL << 17) - 1);\n",
                    latticeIndex, latticeIndex, max + 1);
                ifFalse = String.format(TAB3 + "builder.withLowerBound(%d, %dL << 17).withUpperBound(%d, (1L << 48) - 1);\n",
                    latticeIndex, max + 1, latticeIndex);
            }
            boundsConfig.append(String.format(TAB2 + "if (%s) {\n", varName));
            boundsConfig.append(call.isInverted() ? ifFalse : ifTrue);
            boundsConfig.append(TAB2 + "} else {\n");
            boundsConfig.append(call.isInverted() ? ifTrue : ifFalse);
            boundsConfig.append(TAB2 + "}\n");
            latticeIndex++;
        }
    }

    private void unboundedIntRangeCall(UnboundedNextIntCall.IntRange call, String varName) {
        // TODO: wait for Matthew to fix the bounds on addNextIntCall
        throw new IllegalStateException("ClassGenerator does not support unbounded nextInt() ranges");
    }

    private void doubleRangeCall(NextDoubleCall.DoubleRange call, String varName) {
        boolean hasLowerBound = call.getMin() != 0.0 || call.isMinStrict();
        boolean hasUpperBound = call.getMax() != 1.0 || !call.isMaxStrict();

        if (hasLowerBound && hasUpperBound) {
            throw new IllegalStateException("ClassGenerator does not support nextDouble with two bounds");
        } else if (hasLowerBound) {
            classBody.append(String.format(TAB + " *    boolean %s = rand.nextDouble() %s %f;\n",
                varName,
                call.isMinStrict() ? (call.isInverted() ? "<=" : ">") : (call.isInverted() ? "<" : ">="),
                call.getMin()));
        } else if (hasUpperBound) {
            classBody.append(String.format(TAB + " *    boolean %s = rand.nextDouble() %s %f;\n",
                varName,
                call.isMaxStrict() ? (call.isInverted() ? ">=" : "<") : (call.isInverted() ? ">" : "<="),
                call.getMax()));
        } else {
            classBody.append(TAB + " *    rand.nextDouble();\n");
            classBody.append(String.format(TAB + " *    boolean %s = %s;\n", varName, !call.isInverted()));
        }
        parameters.append("boolean ").append(varName);

        long minLong = (long) (call.getMin() * 0x1.0p53);
        long maxLong = (long) (call.getMax() * 0x1.0p53);

        if (hasLowerBound || hasUpperBound) {
            String ifTrue, ifFalse;
            if (hasLowerBound) {
                boolean lowerOffset = call.isMinStrict() && (minLong & 0x7ffffff) == 0x7ffffff;
                ifTrue = String.format(TAB3 + "builder.withLowerBound(%d, %s(long) (%f * 0x1.0p53)%s >> 27 << 22).withUpperBound(%d, (1L << 48) - 1);\n",
                    latticeIndex, lowerOffset ? "(" : "", call.getMin(), lowerOffset ? " + 1)" : "", latticeIndex);
                boolean upperOffset = call.isMinStrict() || (minLong & 0x7ffffff) != 0;
                ifFalse = String.format(TAB3 + "builder.withLowerBound(%d, 0).withUpperBound(%d, (%s(long) (%f * 0x1.0p53)%s >> 27 << 22) - 1);\n",
                    latticeIndex, latticeIndex, upperOffset ? "(" : "", call.getMin(), upperOffset ? " + 1)" : "");
            } else {
                boolean upperOffset = !call.isMaxStrict() || (maxLong & 0x7ffffff) != 0;
                ifTrue = String.format(TAB3 + "builder.withLowerBound(%d, 0).withUpperBound(%d, (%s(long) (%f * 0x1.0p53)%s >> 27 << 22) - 1);\n",
                    latticeIndex, latticeIndex, upperOffset ? "(" : "", call.getMax(), upperOffset ? " + 1)" : "");
                boolean lowerOffset = !call.isMaxStrict() && (maxLong & 0x7ffffff) == 0x7ffffff;
                ifFalse = String.format(TAB3 + "builder.withLowerBound(%d, %s(long) (%f * 0x1.0p53)%s >> 27 << 22).withUpperBound(%d, (1L << 48) - 1);\n",
                    latticeIndex, lowerOffset ? "(" : "", call.getMax(), lowerOffset ? " + 1)" : "", latticeIndex);
            }
            boundsConfig.append(String.format(TAB2 + "if (%s) {\n", varName));
            boundsConfig.append(call.isInverted() ? ifFalse : ifTrue);
            boundsConfig.append(TAB2 + "} else {\n");
            boundsConfig.append(call.isInverted() ? ifTrue : ifFalse);
            boundsConfig.append(TAB2 + "}\n");
        } else {
            boundsConfig.append(TAB2 + "if (");
            if (!call.isInverted()) {
                boundsConfig.append('!');
            }
            boundsConfig.append(varName).append(") {\n");
            boundsConfig.append(TAB3 + "return ");
            appendClassName(boundsConfig, LongStream.class);
            boundsConfig.append(".empty();\n");
            boundsConfig.append(TAB2 + "}\n");
        }
        latticeIndex++;
    }

    private void longRangeCall(NextLongCall.LongRange call, String varName) {
        // TODO: wait for Matthew to fix the bounds on addNextLongCall
        throw new IllegalStateException("ClassGenerator does not support unbounded nextLong() ranges");
    }

    private void floatRangedCall(String minVarName, String maxVarName, int nextFloats) {
        classBody.append(String.format(TAB + " *    float nextFloat%d = rand.nextFloat();\n", nextFloats));
        classBody.append(String.format(TAB + " *    assert nextFloat%d >= %s && nextFloat%d < %s;\n", nextFloats, minVarName, nextFloats, maxVarName));
        parameters.append("float ").append(minVarName).append(", float ").append(maxVarName);

        boundsConfig.append(String.format(TAB2 + "if (%s >= %s) {\n", minVarName, maxVarName));
        boundsConfig.append(TAB3 + "return ");
        appendClassName(boundsConfig, LongStream.class);
        boundsConfig.append(".empty();\n");
        boundsConfig.append(TAB2 + "}\n");

        boundsConfig.append(String.format(TAB2 + "builder.withLowerBound(%d, (long) (%s * 0x1.0p24f) << 24).withUpperBound(%d, (long) (%s * 0x1.0p24f) << 24);\n",
            latticeIndex, minVarName, latticeIndex, maxVarName));
        latticeIndex++;
    }

    private void intRangedCall(NextIntCall.Ranged call, String minVarName, String maxVarName, int nextInts) {
        classBody.append(String.format(TAB + " *    int nextInt%d = rand.nextInt(%d);\n", nextInts, call.getBound()));
        classBody.append(String.format(TAB + " *    assert nextInt%d >= %s && nextInt%d < %s;\n", nextInts, minVarName, nextInts, maxVarName));
        parameters.append("int ").append(minVarName).append(", int ").append(maxVarName);

        boundsConfig.append(String.format(TAB2 + "if (%s >= %s) {\n", minVarName, maxVarName));
        boundsConfig.append(TAB3 + "return ");
        appendClassName(boundsConfig, LongStream.class);
        boundsConfig.append(".empty();\n");
        boundsConfig.append(TAB2 + "}\n");

        if ((call.getBound() & -call.getBound()) == call.getBound()) {
            int log = Integer.numberOfTrailingZeros(call.getBound());
            classBody.append(String.format(TAB2 + "builder.withLowerBound(%d, (long) %s << %d).withUpperBound(%d, ((long) %s << %d) - 1);\n",
                latticeIndex, minVarName, 48 - log, latticeIndex, maxVarName, 48 - log));
            latticeIndex++;
        } else {
            long residue = (1L << 48) % ((long) call.getBound() << 17);
            boundsConfig.append(String.format(TAB2 + "builder.withLowerBound(%d, 0).withUpperBound(%d, (1L << 48) - %d);\n",
                latticeIndex, latticeIndex, residue));
            latticeIndex++;

            classBody.append(String.format(TAB2 + "builder.withLowerBound(%d, (long) %s << 17).withUpperBound(%d, ((long) %s << 17) - 1);\n",
                latticeIndex, minVarName, latticeIndex, maxVarName));
            latticeIndex++;
        }
    }

    private void unboundedIntRangedCall(String minVarName, String maxVarName, int nextInts) {
        classBody.append(String.format(TAB + " *    int nextInt%d = rand.nextInt();\n", nextInts));
        classBody.append(String.format(TAB + " *    assert nextInt%d >= %s && nextInt%d < %s;\n", nextInts, minVarName, nextInts, maxVarName));
        parameters.append("int ").append(minVarName).append(", int ").append(maxVarName);

        boundsConfig.append(String.format(TAB2 + "if (%s >= %s) {\n", minVarName, maxVarName));
        boundsConfig.append(TAB3 + "return ");
        appendClassName(boundsConfig, LongStream.class);
        boundsConfig.append(".empty();\n");
        boundsConfig.append(TAB2 + "}\n");

        classBody.append(String.format(TAB2 + "builder.withLowerBound(%d, (long) %s << 16).withUpperBound(%d, ((long) %s << 16) - 1);\n",
            latticeIndex, minVarName, latticeIndex, maxVarName));
        latticeIndex++;
    }

    private void doubleRangedCall(String minVarName, String maxVarName, int nextDoubles) {
        classBody.append(String.format(TAB + " *    double nextDouble%d = rand.nextDouble();\n", nextDoubles));
        classBody.append(String.format(TAB + " *    assert nextDouble%d >= %s && nextDouble%d < %s;\n", nextDoubles, minVarName, nextDoubles, maxVarName));
        parameters.append("double ").append(minVarName).append(", double ").append(maxVarName);

        boundsConfig.append(String.format(TAB2 + "if (%s >= %s) {\n", minVarName, maxVarName));
        boundsConfig.append(TAB3 + "return ");
        appendClassName(boundsConfig, LongStream.class);
        boundsConfig.append(".empty();\n");
        boundsConfig.append(TAB2 + "}\n");

        boundsConfig.append(String.format(TAB2 + "builder.withLowerBound(%d, (long) (%s * 0x1.0p53) >> 27 << 22).withUpperBound(%d, (((long) (%s * 0x1.0p53) + 0x7ffffff) >> 27 << 22) - 1);\n",
            latticeIndex, minVarName, latticeIndex, maxVarName));
        latticeIndex++;
    }

    private void longRangedCall(String minVarName, String maxVarName, int nextLongs) {
        classBody.append(String.format(TAB + " *    long nextLong%d = rand.nextLong();\n", nextLongs));
        classBody.append(String.format(TAB + " *    assert nextLong%d >= %s && nextLong%d < %s;\n", nextLongs, minVarName, nextLongs, maxVarName));
        parameters.append("long ").append(minVarName).append(", long ").append(maxVarName);

        String minFirstSeedName = "longMinFirstSeed" + nextLongs;
        boundsConfig.append(String.format(TAB2 + "long %s = %s >>> 32 << 16;\n", minFirstSeedName, minVarName));
        boundsConfig.append(String.format(TAB2 + "if (%s < 0) {\n", minVarName));
        boundsConfig.append(String.format(TAB3 + "%s += (1L << 16);\n", minFirstSeedName));
        boundsConfig.append(TAB2 + "}\n");
        String maxFirstSeedName = "longMaxFirstSeed" + nextLongs;
        boundsConfig.append(String.format(TAB2 + "long %s = ((%s + 0xffffffffL) >>> 32 << 16) - 1;\n", maxFirstSeedName, maxVarName));
        boundsConfig.append(String.format(TAB2 + "if (%s < 0) {\n", maxVarName));
        boundsConfig.append(String.format(TAB3 + "%s += (1L << 16);\n", maxFirstSeedName));
        boundsConfig.append(TAB2 + "}\n");
        boundsConfig.append(String.format(TAB2 + "builder.withLowerBound(%d, %s).withUpperBound(%d, %s);\n", latticeIndex, minFirstSeedName, latticeIndex, maxFirstSeedName));
        latticeIndex++;
    }

    private void appendClassName(StringBuilder sb, Class<?> clazz) {
        String packageName = clazz.getPackage().getName();
        String canonicalName = clazz.getCanonicalName();
        if (!packageName.equals("java.lang") && !packageName.equals(this.packageName)) {
            Class<?> importedClass;
            for (importedClass = clazz; importedClass.getDeclaringClass() != null; importedClass = importedClass.getDeclaringClass())
                ;
            imports.add(importedClass.getCanonicalName());
        }
        sb.append(packageName.isEmpty() ? canonicalName : canonicalName.substring(packageName.length() + 1));
    }
}
